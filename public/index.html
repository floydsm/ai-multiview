<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Millicast Multiviewer</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#111; color:#fff; overflow:hidden; }
    header { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; padding:10px; background:#1a1a1a; position:relative; z-index:1; }
    button { background:#6d5bf6; color:#fff; border:0; padding:8px 12px; border-radius:10px; cursor:pointer; }
    button.secondary { background:#2f2f2f; }
    .stage { height: calc(100vh - var(--header-h, 56px)); padding:10px; box-sizing: border-box; }
    .grid { display:grid; gap:10px; width:100%; height:100%; }
    .tile { background:#000; border-radius:12px; position:relative; overflow:hidden; }
    .badge { position:absolute; left:8px; top:8px; background:rgba(0,0,0,.6); padding:4px 8px; border-radius:8px; font-size:13px; z-index:2; display:flex; gap:8px; align-items:center; }
    .badge .name { border-bottom:1px dashed transparent; cursor:text; }
    .badge .name:hover { border-bottom-color: rgba(255,255,255,.4); }
    .count { background:rgba(255,255,255,.12); padding:2px 6px; border-radius:999px; font-size:11px; }
    .actions { position:absolute; left:50%; bottom:8px; transform:translateX(-50%); display:flex; gap:6px; z-index:2; }
    .actions button { font-size:12px; background:rgba(255,255,255,.18); }
    .video { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .video iframe { width:100%; height:100%; border:0; object-fit:contain; background:#000; }
    #lastUpdate { font-size:12px; opacity:.75; margin-left:8px; }
  </style>
</head>
<body>
  <header id="topbar">
    <button id="btnActive">Get Active</button>
    <button class="secondary" id="btnShowAll">Show All</button>
    <span id="lastUpdate"></span>
  </header>

  <div class="stage">
    <div id="grid" class="grid"></div>
  </div>

  <script>
    // ---- Loose-matching default names ----
    // We'll normalize keys and incoming IDs/names by removing non-alphanumerics and uppercasing.
    const RAW_DEFAULT_NAMES = {
      "QTL07-W02STR003": "Andrew",
      "QTL13-W02STR013": "Andrew",
      "QTL12-W02STR012": "Nick",
      "QTL06-W02STR001": "Nick",
      "QTL14-W02STR014": "CJ",
      "QTL15-W02STR015": "CJ",
      "CQTL1-W01STR001": "Shawn",
      "QTL08-W01STR004": "Shawn",
      "QTL10-W02STR010": "Israel",
      "QTL11-W02STR011": "Phil",
      "QTL 16-W03STR001": "Nuria",     // includes space variant
      "QTL16-W03STR001": "Nuria",
      "MX QTL-W13STR002": "Aurora",
      "MXQTL-W13STR002": "Aurora",
      "MX QTL 2-W13STR003": "Pau",
      "MXQTL2-W13STR003": "Pau",
      "QTL17-W02STR025": "Robert"
    };
    const norm = (s) => String(s||"").toUpperCase().replace(/[^A-Z0-9]/g, "");
    const DEFAULT_NAMES = Object.fromEntries(Object.entries(RAW_DEFAULT_NAMES).map(([k,v]) => [norm(k), v]));

    const TARGET_RATIO = 16/9; // layout uses this for grid sizing; videos use 'contain' to preserve their own ratio

    let tiles = []; // {id,name,url,viewers,visible,_dom?}
    let grid, header, stage, lastUpdateEl;
    let pollTimer = null;

    const nameKey = (id)=>'mv_name_'+(id||'blank');

    async function fetchActive() {
      const r = await fetch('/.netlify/functions/millicast', { method:'GET' });
      if (!r.ok) throw new Error(await r.text());
      const json = await r.json();
      return json.streams || [];
    }

    function computeBestColumns(n, W, H, ratio) {
      let bestC = 1, bestArea = -1;
      for (let c = 1; c <= n; c++) {
        const rows = Math.ceil(n / c);
        const tileW = W / c;
        const tileH = tileW / ratio;
        const totalH = rows * tileH;
        if (totalH <= H) {
          const area = tileW * tileH;
          if (area > bestArea) { bestArea = area; bestC = c; }
        }
      }
      return bestArea < 0 ? Math.min(n, Math.max(1, Math.floor(W / 240))) : bestC;
    }
    function layout() {
      const visible = tiles.filter(t=>t.visible);
      const n = visible.length || 1;
      const rect = stage.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      const cols = computeBestColumns(n, W, H, TARGET_RATIO);
      const rows = Math.ceil(n / cols);
      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    }

    function render() {
      grid.innerHTML = '';
      tiles.forEach((t, i) => {
        if (!t.visible) return;
        const d = document.createElement('div');
        d.className = 'tile';

        const badge = document.createElement('div');
        badge.className = 'badge';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'name';
        nameSpan.textContent = t.name || ('Stream ' + (i+1));
        nameSpan.title = 'Click to rename';
        nameSpan.contentEditable = true;
        nameSpan.addEventListener('keydown', (ev)=>{
          if (ev.key === 'Enter') { ev.preventDefault(); nameSpan.blur(); }
        });
        nameSpan.addEventListener('blur', ()=>{
          const newName = nameSpan.textContent.trim() || t.name || ('Stream ' + (i+1));
          t.name = newName;
          localStorage.setItem(nameKey(t.id), newName);
          nameSpan.textContent = newName;
        });
        badge.appendChild(nameSpan);

        const count = document.createElement('span');
        count.className = 'count';
        count.textContent = (t.viewers ?? '-') + '';
        badge.appendChild(count);
        d.appendChild(badge);

        const v = document.createElement('div');
        v.className = 'video';
        const iframe = document.createElement('iframe');
        iframe.allow = 'autoplay; fullscreen';
        iframe.src = t.url || 'about:blank';
        v.appendChild(iframe);
        d.appendChild(v);

        const actions = document.createElement('div');
        actions.className = 'actions';
        const hideBtn = document.createElement('button');
        hideBtn.textContent = 'Hide';
        hideBtn.onclick = ()=> { t.visible = false; render(); layout(); };
        actions.appendChild(hideBtn);
        d.appendChild(actions);

        t._dom = { countEl: count, nameEl: nameSpan };
        grid.appendChild(d);
      });
      layout();
    }

    function pickDefaultName(id, serverName) {
      const nId = norm(id);
      const nSrv = norm(serverName);
      // Direct lookup
      if (DEFAULT_NAMES[nId]) return DEFAULT_NAMES[nId];
      if (DEFAULT_NAMES[nSrv]) return DEFAULT_NAMES[nSrv];
      // Soft match: if any key is contained in the id/name or vice versa
      for (const [k, v] of Object.entries(DEFAULT_NAMES)) {
        if (nId.includes(k) || k.includes(nId) || nSrv.includes(k) || k.includes(nSrv)) {
          return v;
        }
      }
      return serverName || id || 'Stream';
    }

    function mergeUpdate(newList) {
      const idx = new Map(tiles.map(t=>[t.id, t]));
      const newIds = new Set();
      newList.forEach(s => {
        const id = s.id || s.name || s.playerUrl;
        newIds.add(id);
        const existing = idx.get(id);
        if (existing) {
          existing.viewers = s.viewers ?? existing.viewers ?? null;
          if (existing._dom?.countEl) existing._dom.countEl.textContent = (existing.viewers ?? '-') + '';
          // Only update the name if user hasn't customized locally
          if (!localStorage.getItem(nameKey(id))) {
            const fallback = pickDefaultName(id, s.name);
            existing.name = fallback;
            if (existing._dom?.nameEl) existing._dom.nameEl.textContent = fallback;
          }
        } else {
          const savedName = localStorage.getItem(nameKey(id));
          const fallback = pickDefaultName(id, s.name);
          tiles.push({
            id,
            name: savedName || fallback,
            url: s.playerUrl || '',
            viewers: s.viewers ?? null,
            visible: true
          });
        }
      });
      // Hide streams that are no longer active
      tiles = tiles.map(t => newIds.has(t.id) ? t : ({ ...t, visible: false }));
    }

    async function refreshTick() {
      try {
        const list = await fetchActive();
        mergeUpdate(list);
        lastUpdateEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      } catch {}
    }
    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(refreshTick, 5000);
    }

    async function initialLoad() {
      try{
        const list = await fetchActive();
        tiles = list.map(s => {
          const id = s.id || s.name || s.playerUrl;
          const savedName = localStorage.getItem(nameKey(id));
          const fallback = pickDefaultName(id, s.name);
          return { id, name: savedName || fallback, url: s.playerUrl || '', viewers: s.viewers ?? null, visible: true };
        });
        render();
        lastUpdateEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
        startPolling();
      } catch (e) {}
    }

    window.addEventListener('DOMContentLoaded', () => {
      header = document.getElementById('topbar');
      stage = document.querySelector('.stage');
      grid = document.getElementById('grid');
      lastUpdateEl = document.getElementById('lastUpdate');

      document.getElementById('btnActive').onclick = () => initialLoad();

      const resizeHeaderVar = () => {
        const h = header.getBoundingClientRect().height;
        document.documentElement.style.setProperty('--header-h', Math.round(h) + 'px');
      };
      resizeHeaderVar();
      new ResizeObserver(()=>{ resizeHeaderVar(); render(); }).observe(document.body);
      new ResizeObserver(()=>{ render(); }).observe(stage);

      document.getElementById('btnShowAll').onclick = () => { tiles = tiles.map(t=>({...t, visible:true})); render(); layout(); };

      initialLoad();
    });
  </script>
</body>
</html>
