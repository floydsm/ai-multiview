<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Millicast Multiviewer</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    header {
      background: #111;
      padding: 0.5em;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1em;
      flex-wrap: wrap;
    }
    header button, header label, header select, header input {
      font-size: 1em;
      padding: 0.3em 0.6em;
      border: none;
      border-radius: 4px;
    }
    header button {
      background: #444;
      color: white;
      cursor: pointer;
    }
    header button:hover {
      background: #666;
    }
    #grid {
      flex: 1;
      display: grid;
      gap: 2px;
      background: black;
      padding: 2px;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: black;
      object-fit: contain;
    }
    .tile {
      position: relative;
      background: black;
    }
    .overlay {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <header>
    <button id="getActive">Get Active</button>
    <label><input type="checkbox" id="toggleAuto" /> Auto refresh</label>
    <select id="refreshInterval">
      <option value="5000">5s</option>
      <option value="10000" selected>10s</option>
      <option value="30000">30s</option>
    </select>
    <span id="lastUpdated" style="font-size:0.9em;opacity:0.8"></span>
  </header>
  <div id="grid"></div>

  <script>
    const gridEl = document.getElementById('grid');
    const getActiveBtn = document.getElementById('getActive');
    const toggleAuto = document.getElementById('toggleAuto');
    const refreshIntervalEl = document.getElementById('refreshInterval');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    let streams = [];
    let autoTimer = null;

    async function fetchActive() {
      try {
        const res = await fetch('/.netlify/functions/millicast', { method: 'POST' });
        const data = await res.json();
        streams = data.streams || [];
        renderGrid();
        updateLastUpdated();
      } catch (e) {
        console.error('Error fetching streams', e);
      }
    }

    function updateLastUpdated() {
      lastUpdatedEl.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
    }

    function fitGrid() {
      const count = streams.length;
      const containerHeight = window.innerHeight - document.querySelector('header').offsetHeight;
      let cols = Math.ceil(Math.sqrt(count));
      let rows = Math.ceil(count / cols);
      let tileHeight = containerHeight / rows;
      let tileWidth = window.innerWidth / cols;
      let ratio = 16 / 9;
      if (tileWidth / tileHeight > ratio) {
        tileWidth = tileHeight * ratio;
      } else {
        tileHeight = tileWidth / ratio;
      }
      gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gridEl.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    }

    function renderGrid() {
      gridEl.innerHTML = '';
      streams.forEach(s => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        const iframe = document.createElement('iframe');
        iframe.src = s.playerUrl;
        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        overlay.textContent = `${s.name} (${s.viewers} viewers)`;
        tile.appendChild(iframe);
        tile.appendChild(overlay);
        gridEl.appendChild(tile);
      });
      fitGrid();
    }

    function updateViewerCounts() {
      fetch('/.netlify/functions/millicast', { method: 'POST' })
        .then(res => res.json())
        .then(data => {
          data.streams.forEach(s => {
            const tile = [...gridEl.children].find(t => t.querySelector('.overlay').textContent.startsWith(s.name));
            if (tile) {
              tile.querySelector('.overlay').textContent = `${s.name} (${s.viewers} viewers)`;
            }
          });
          updateLastUpdated();
        })
        .catch(err => console.error('Error updating viewers', err));
    }

    getActiveBtn.addEventListener('click', fetchActive);

    toggleAuto.addEventListener('change', () => {
      if (toggleAuto.checked) {
        autoTimer = setInterval(updateViewerCounts, parseInt(refreshIntervalEl.value));
      } else {
        clearInterval(autoTimer);
      }
    });

    refreshIntervalEl.addEventListener('change', () => {
      if (toggleAuto.checked) {
        clearInterval(autoTimer);
        autoTimer = setInterval(updateViewerCounts, parseInt(refreshIntervalEl.value));
      }
    });

    window.addEventListener('resize', fitGrid);
  </script>
</body>
</html>
